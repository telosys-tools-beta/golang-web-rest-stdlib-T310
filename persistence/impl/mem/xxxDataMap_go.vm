// Created on $today.date ( Time $today.time )
// Generated by $generator.name ( version $generator.version )
$env.setLanguage('GO')
#checkId($entity)
##
#set($entityName = $fn.capitalize(${entity.name}) )
#set($entityNameLC = $fn.toLowerCase(${entity.name}) )
#set($keyAttributesWithType = $fn.argumentsListWithType($entity.keyAttributes) )
#set($keyAttributes = $fn.argumentsList($entity.keyAttributes) )
##
#set( $keyFields = "" )
#foreach( $attribute in $entity.keyAttributes)
#set( $x = $fn.capitalize(${attribute.name})  )
#if( $foreach.count < 2 )
#set( $keyFields = "${entityNameLC}.${x}" )
#else
#set( $keyFields = $keyFields + ", " + "${entityNameLC}.${x}" )
#end
#end

package memdb

import (
	"sync"

	"internal/entities"
	"internal/log"
)

// Structure definition
type ${entityName}DataMap struct {
	dataMap map[string]entities.${entityName} // the map to store ${entityName} entities
	lock    sync.RWMutex
}

var ${entityNameLC}DataOnce sync.Once
var ${entityNameLC}DataMap  ${entityName}DataMap

func Get${entityName}DataMap() *${entityName}DataMap {
	log.Debug("${entityName}DataMap - Get${entityName}DataMap() ")
	
	// From Golang doc :
	// "func (o *Once) Do(f func())"
	// "Do" calls the function "f" if and only if Do is being called for the first time for this instance of Once. 
	// In other words, given "var once Once" if "once.Do(f)" is called multiple times,
	// only the first call will invoke f, even if f has a different value in each invocation. 
	// A new instance of Once is required for each function to execute. 
	${entityNameLC}DataOnce.Do(new${entityName}DataMap) // called only 1 time
	return &${entityNameLC}DataMap
}

func new${entityName}DataMap() {
	log.Debug("${entityName}DataMap - new${entityName}DataMap() ***** ")
	${entityNameLC}DataMap = ${entityName}DataMap{
		dataMap: make(map[string]entities.${entityName}),
		lock:    sync.RWMutex{},
	}
}

func (this *${entityName}DataMap) Read(${keyAttributesWithType}) *entities.${entityName} {
	key := buildKey(${keyAttributes})
	log.Debug("${entityName}DataMap - read '%s' ", key)
	this.lock.RLock()
	defer this.lock.RUnlock()
	${entityNameLC}, exists := this.dataMap[key]
	if exists {
		return &${entityNameLC}
	} else {
		return nil
	}
}
func (this *${entityName}DataMap) Exists(${keyAttributesWithType}) bool {
	key := buildKey(${keyAttributes})
	log.Debug("${entityName}DataMap - exists '%s' ", key)
	this.lock.RLock()
	defer this.lock.RUnlock()
	_, exists := this.dataMap[key]
	return exists
}

func (this *${entityName}DataMap) Write(${entityNameLC} entities.${entityName}) {
	key := buildKey($keyFields)
	log.Debug("${entityName}DataMap - write '%s' : %+v ", key, ${entityNameLC})
	this.lock.Lock()
	defer this.lock.Unlock()
	this.dataMap[key] = ${entityNameLC}
}

func (this *${entityName}DataMap) Remove(${keyAttributesWithType}) {
	key := buildKey(${keyAttributes})
	log.Debug("${entityName}DataMap - remove '%s' ", key)
	this.lock.Lock()
	defer this.lock.Unlock()
	delete(this.dataMap, key) // delete in map
}

func (this *${entityName}DataMap) Values() []entities.${entityName} {
	this.lock.Lock()
	defer this.lock.Unlock()
	var a = make([]entities.${entityName}, len(this.dataMap))
	i := 0
	for _, v := range this.dataMap {
		a[i] = v
		i++
	}
	return a
}
